--> Docker

- cloud Hypervisor is called - Xen/Nitro
- Containers package an application and its dependecies together, making the application easily runnable on any system that has Docker installed

Note: By Default Docker works with the root user and other users can only access to Docker with sudo commands. However, 
we can bypass the sudo commands by creating a new group with the name docker ad add ec2_user.

    * sudo groupadd docker
    * sudo usermod -a -G docker ec2-user
    * newgrp docker
    * sudo chmod 666 /var/run/docker.sock

--> Default location
    * docker version            --> To check the version in machine
    * docker --version          --> To check both client and server status
    * docker pull <image>       --> to downloa the image from docker hub
    * docker run -dt <image>
    * docker run -dt --name <container-Name> <image>
    * docker ps 
    * docker ps -a 
    * docker run -dt -p <localhost-port>:<container-port> <image_name>
    * docker run -dt --name <container-name> -p source-port:container-port <image>
    * docker inspect image nginx   ## to check image details
    * docker ps -a | grep Exit    ## To check only stopped Containers

--> docker attach
    - docker attach <container-id>
    - CTRL + P & CTRL + Q  #use this to exit from container terminal without stopping container.
 
-- To login into the container
    * docker exec -it <container-id/name> /bin/bash

*****  EXIT[0] About a minut ago
    - If a container crashed, exit code help debug why
    - 0 = stopped manually
    - Non-Zero = Crashed or has an error.
    - Exited (137) → Out of memory or forced stop
    - Exited (1)   → App crash or command failed

--> Conatiner usage command: 
    - docker stats <container-id  # View live resource usage


--> Dockerfile Instructions:
    
    * USER          --
    * VOLUME        --

--> Image building
    - docker build -t test .

--> Push image to remote resigtry (Dockerhub, ECR)
    -  


=================================>

-- important points
- if a container is created from image and it is not possible to delete the container. even if container
is in stopped state as well
- detach vs interactive
    - You use interactive mode for testing, debugging, or manually inspecting containers.
    - detach mode (-d) Runs in background
    - interactive mode (-it) allows to access shell in container for typing commands.
- 


========================================================================

-->
- catalina.sh 
- If a docker provider delete the image in dockerhub? will it work docker container?
- Trivi scanner is a scanner to check the image is secure or not
- Tomcat dependencies are located in webapps.dist
    - /usr/local/tomcat/webapps.dist
- we should not use exit to come out of container, it will stop the container. Use (CTRL + p + q)
- 

=============================================================================

Docker file:

- by using docker file we can pass the Instructions
    - 

    * FROM          -- To Pull image from docker hub (UBUNTU/centos)
    * RUN           -- apt-get update -y  (locally executable commands)
    * RUN           -- mkdir test
    * WORKDIR       -- works like CD command
    * COPY          -- Copy the files from local to docker
    * ADD           -- works like copy instructions, we can add here URL's also , we can call from remote locations
    * EXPOSE        -- Default port number of application
    * CMD           -- Executable command in container
    * ENTRYPOINT    -- Same like CMD executable command in container but here we can't change commands
                    while docker run time.

- FROM
- COPY:
    * COPY vs ADD
        - COPY takes in a source and destination. It only lets you copy in a local file or directory from you host.
        - ADD lets you do that too, but it also supports 2 other sources.
        - First, you can use a URL instead of a local file/directory.
        - Secondly, you can extract a tar file from the source directly into the destination.
        - Using ADD to fetch packages from remote URL is strongly discourages; you should use curl or wget instead using RUN
    *** imp: incase if you want copy a file/directory you can use of COPY. incase if you want to copy a compressed directory by extract and copy in container then use ADD.

- EXPOSE:
    - The Expose instruction informs Docker that the container listens on the specified network ports at runtime.
    - The Expose instruction does not actually publish the port.
    - If funtions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published.

- HEALTHCHECK Overview of ENTRYPOINT:
    - HEALTHCHECK instruction Docker allows us to tell the platform on how to test that our application is healthy.
    - When Docker starts a container, it monitors the process that the container runs. If the process ends, the container exits.
    - That's just a basic and does not neccessarily tel the detail about the application.
     
     ex: FROM ubuntu
         HEALTHCHECK --interval=5s CMD ping -c 8.8.8.8

         --interval=DURATION(default: 30s)
         --timeout=DURATION(default: 30s)
         --start-period=DURATION(default:0s)
         --retries=N(default:3)

- HEALTHCHECK option:
    - Exit Codes:
        * 0: Success  -> The container is healthy and eady for use
        * 1: Failure  -> The container is not working correctly
        * 2: Reserved -> Do not use this exit code
    --> docker run -dt --name tmp  --health-cmd "curl --fail http://localhost" --health-interval=5s busybox sh
    --> docker run -dt --name tmp2 --health-cmd "curl -f http://localhost" --health-interval=5s --health-retries=1 busybox sh

- ENTRYPOINT:
    * The best use for ENTRYPOINT is to set the image's main command.
    * ENTRYPOINT doesn't allow you to override the command.
    * IT is important to understand distinction between CMD and CONTRYPOINT.

- WORKDIR:
    * The WORKDIR intrcution sets the working directory for any RUN, CMD, ENTRYPOINT, COPY and ADD instructions that follow it in the Dockerfile.
    * Imp Pointer:
        -- The WORKDIR instruction can be used multiple times in a Dockerfile
        - Ex:
            WORKDIR /a
            WORKDIR b
            WORKDIR c
            RUN pwd

            --> output = /a/b/c

- ENV:
    * The ENV instruction sets the envrionment variable <key> to the value <value>.
    * ex:
        ENV NGINX 1.2
        RUN curl -SL http://example.com/web.$NGINX.tar.xz
        RUN tar -xzvf web-$NGINX.tar.xz
    * Setting Envrionment Variables from CLI
        > You can use the -e, --env, and --env-file flags to set simple envrionment variables in the container you're running, or overwrite variables that are defined in the Dockerfile of the image you're running.
        Ex:
        -> docker run --env VAR1=Value1 --env VAR2 ubuntu ubuntu env | grep VAR


--> Tagging Docker Images:
    - docker build -t demo:v1 .
    - docker build -t demo:latest mydemo:v1 .
        * here demo:latest is primary image and "mydemo:v1" alias name of the primary image(both get the same image ID)

--> Docker Commit:
    - Whenever you make changes inside the container, it can be useful to commit a container's file changes or setting into a new image.
    - By default, the container being commited and its processes will be paused while the image commited.
    ** docker container commit <CONTAINER-ID> <NEW-CONTAINER-NAME>
    -->Change Option while commiting
        - The --change option will apply Dockerfile insturctions to the image that is created.
        - Supported Dockerfile instructions:
            * CMD | ENTRPOINT | ENV| EXPOSE
            * LABEL | ONBUILD | USER | VOLUME | WORKDIR

--> Layers of Docker image:
    - A Docker image is built up from a series of layers.
    - Each layer represents an instruction in the image's Dockerfile.
    - A Major difference between a container and an image is the top writable layer.
    - All writes to the container that add new or modify existing data are stored in this writable layer.
    - Always use && to avoid more layers in containers creation, when you have less layers the performance of the container is good

--> Managing images using CLI:
    - 

--> Inpsecting Docker images
    - A Docker image contains lot of information, some of these include:
        * Creation Date
        * Command
        * Envrionment Variables
        * Architecture
        * OS
        * Size
    - docker image inspect command allows us to see all the information associated with a docker image.
    ex:
    - docker image inspect nginx --format='{{.Id}}'
    - docker image inspect nginx --format='{{json.containerconfig}}'

--> Image Pruning Steps
    - Docker image prune command allows us to clean up unused images.
    - by Default, the above command will only clean up dangling imges.
    - Dangling images- Image with Tags and image not referenced by any container.
    ex: 
    - docker image prune
    - docker images prune -a

-> Modifying Image to Single Layer
    - In a generic scenorio, the more the layers an image has, the more the size of the image.
    - Some of the image size goes from 5GB to 10GB.
    - Flattening an image to single layer can help reduce the overall size of the image.

   >> Process:
    - docker images
    - docker container run -dt --name mybuntu ubuntu
    - docker ps
    - docker export mybuntu > myubuntudemo.tar
    - ls -l myubuntudemo.tar
    - cat myubuntudemo.tar | docker import - myubuntu:latest

--> Docker Regitries:
    - A Registry a stateless, highly scalable server side application that stores and lets you distribute Docker images.
    - Docker Hub is the simplest example that all of us must have used.
    - There are various types of registry available, which includes:
        * Docker Registry (basic Features)
        * Docker Trusted Registry (Enterprise Edition)
        * Private Repository (AWS ECR)
        * Docker Hub
    
--> Applyin Filters for Docker Images:
    - docker search --limit 5
    - docker search --filter "is-official=true"

--> Moving Images Across Host:
    - The docker save command will save one or more images to a tar archive
    - docker save busybox > busybox.tar   # once tar file is create send the tar file to destination user
    - the docker load command will load an image from a tar archive
    - docker load < busybox.tar

--> Build cache
    - Docker created container images using layers.
    - Each command that is found in a Dockerfile creates a new layer.
    - Docker uses a layer cache to optimize the process of building Docker images and make it faster.
    - IMP Pointer:
        ** If the cache can't be used for a particular layer, all subsequent layers won't be loaded from the cache.




